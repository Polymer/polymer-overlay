<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<link rel="import" href="../polymer-key-helper/polymer-key-helper.html">

<polymer-element name="polymer-overlay" attributes="opened autoCloseDisabled">
	<template>
		<polymer-key-helper id="keyHelper"></polymer-key-helper>
		<link rel="stylesheet" href="polymer-overlay.css">
		<link rel="stylesheet" polymer-scope="global" href="polymer-overlay-global.css">
		<content></content>
	</template>
	<script>
		(function() {
			// track overlays for z-index and focus managemant
			var overlays = [];
			var trackOverlays = function(inOverlay) {
				if (inOverlay.opened) {
					var z0 = currentOverlayZ();
					overlays.push(inOverlay);
					var z1 = currentOverlayZ();
					if (z1 <= z0) {
						applyOverlayZ(inOverlay, z0);
					} 
				} else {
					var i = overlays.indexOf(inOverlay);
					if (i >= 0) {
						overlays.splice(i, 1);
						setZ(inOverlay, null);
					}
				}
			}
			
			var applyOverlayZ = function(inOverlay, inAboveZ) {
				setZ(inOverlay, inAboveZ + 2);
			}
			
			var setZ = function(inNode, inZ) {
				inNode.style.zIndex = inZ;
			}
		
			var currentOverlay = function() {
				return overlays[overlays.length-1];
			}
			
			var DEFAULT_Z = 10;
			
			var currentOverlayZ = function() {
				var z;
				var current = currentOverlay();
				if (current) {
					var z1 = window.getComputedStyle(current).zIndex;
					if (!isNaN(z1)) {
						z = Number(z1);
					}
				}
				return z || DEFAULT_Z;
			}
			
			var focusOverlay = function() {
				var current = currentOverlay();
				if (current) {
					current.applyFocus();
				}
			}
		
			Polymer('polymer-overlay', {
				/**
				 * Set opened to true to show an overlay and to false to hide it.
				 * A g-overlay may be made intially opened by setting its opened 
				 * attribute.
				 * @attribute opened
				 * @type boolean
				 * @default false
				 */
				opened: false,
				/**
				 * By default an overlay will close automatically if the user taps outside
				 * it or presses the escape key. Disable this behavior by setting the 
				 * autoCloseDisabled property to true.
				 * @attribute autoCloseDisabled
				 * @type boolean
				 * @default false
				 */
				autoCloseDisabled: false,
				timeout: 1000,
				captureEventType: 'tap',
				ready: function() {
					if (this.tabIndex === undefined) {
						this.tabIndex = -1;
					}
					this.setAttribute('touch-action', 'none');
				},
				/** 
				 * Toggle the opened state of the overlay.
				 * @method toggle
				 */
				toggle: function() {
					this.opened = !this.opened;
				},
				openedChanged: function() {
					this.renderOpened();
					trackOverlays(this);
					if (!this.autoCloseDisabled) {
						this.enableCaptureHandler(this.opened);
					}
					this.enableResizeHandler(this.opened);
					this.fire('opened', this.opened);
				},
				enableHandler: function(inEnable, inMethodName, inNode, inEventName, inCapture) {
					var m = 'bound' + inMethodName;
					this[m] = this[m] || this[inMethodName].bind(this);
					
					inNode[inEnable ? 'addEventListener' : 'removeEventListener'](
						inEventName, this[m], inCapture);
				},
				enableResizeHandler: function(inEnable) {
					this.enableHandler(inEnable, 'resizeHandler', window, 
						'resize');
				},
				enableCaptureHandler: function(inEnable) {
					this.enableHandler(inEnable, 'captureHandler', document, 
						this.captureEventType, true);
				},
				getFocusNode: function() {
					return this.querySelector('[autofocus]') || this;
				},
				// TODO(sorvell): nodes stay focused when they become un-focusable due to
				// an ancestory becoming display: none; file bug.
				applyFocus: function() {
					var focusNode = this.getFocusNode();
					if (this.opened) {
						focusNode.focus();
					} else {
						focusNode.blur();
						focusOverlay();
					}
				},
				renderOpened: function() {
					this.classList.remove('closing');
					this.classList.add('revealed');
					// continue styling after delay so display state can change without
					// aborting transitions
					this.asyncMethod('continueRenderOpened');
				},
				continueRenderOpened: function() {
					this.classList.toggle('opened', this.opened);
					this.classList.toggle('closing', !this.opened);
					//this.animating = this.asyncMethod('completeOpening', null, this.timeout);
				},
				completeOpening: function() {
					//clearTimeout(this.animating);
					this.animating = null;
					this.classList.remove('closing');
					this.classList.toggle('revealed', this.opened);
					this.applyFocus();
				},
				openedAnimationEnd: function(e) {
					if (!this.opened) {
						this.classList.remove('animation');
					}
					// same steps as when a transition ends
					this.openedTransitionEnd(e);
				},
				openedTransitionEnd: function(e) {
					// TODO(sorvell): Necessary due to 
					// https://bugs.webkit.org/show_bug.cgi?id=107892
					// Remove when that bug is addressed.
					if (e.target == this) {
						this.completeOpening();
						e.stopPropagation();
						e.cancelBubble = true;
					}
				},
				openedAnimationStart: function(e) {
					this.classList.add('animation');
					e.stopPropagation();
					e.cancelBubble = true;
				},
				tapHandler: function(e) {
					if (e.target && e.target.hasAttribute('overlay-toggle')) {
						this.toggle();
					} else {
						if (this.autoCloseJob) {
							this.autoCloseJob.stop();
							this.autoCloseJob = null;
						}
					}
				},
				// TODO(sorvell): This approach will not work with modal. For this we need a
				// scrim.
				captureHandler: function(e) {
					if (!this.autoCloseDisabled && (currentOverlay() == this) && (this 
							!= e.target) && !(this.contains(e.target))) {
						this.autoCloseJob = this.job(this.autoCloseJob, function() {
							this.opened = false;
						});
					}
				},
				keydownHandler: function(e) {
					if (!this.autoCloseDisabled && (e.keyCode == this.$.keyHelper.ESCAPE_KEY)) {
						this.opened = false;
						e.stopPropagation();
						e.cancelBubble = true;
					}
				},
				/**
				 * Extensions of g-overlay should implement the resizeHandler
				 * method to adjust the size and position of the overlay when the 
				 * browser window resizes.
				 * @method resizeHandler
				 */
				resizeHandler: function() {
				}
			});
		})();
	</script>
</polymer-element>
